
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Module 2 — Locators and Java Tests</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid="Google Analytics ID"
                  id="Module2-SeleniumJava"
                  title="Module 2 — Locators and Java Tests"
                  environment="web"
                  feedback-link="https://forms.gle/CGu4QchgBxxWnNJK8">
    
      <google-codelab-step label="2.01 What You&#39;ll Learn" duration="5">
        <p>This module is derived from content in chapters 6-7 of <em>The Selenium GuidebookJava Edition</em> By Dave Haeffner. This module will touch lightly on how to write a basic test, and teach users about how to set up a project, as well as learn about how Selenium locates and interacts with elements on a &#34;page&#34;, which can be any view or even object within a webpage.</p>
<h2 is-upgraded>Objectives</h2>
<ul>
<li>Use Maven along with IntelliJ to run local tests and manage dependencies on your machine</li>
<li>Understand that good tests are atomic: Tests are grouped by functionality and are named descriptively. Good * tests also use test runners, and are maintained in version control systems</li>
<li>Be able to define a test strategy and use a testing strategy like BDD and TDD to create test cases</li>
<li>Use the browser dev tools console to test locators on the page using elements such as class, id, XPath, and more</li>
<li>Choose and verify locators for a test class and write code that successfully uses the locators</li>
<li>Write a test case with @Before, @After annotations from the JUnit library, and a @Test assertion, then run it successfully on your local machine</li>
<li>Write and validate tests that can both succeed and fail, while accounting for different possible failure scenarios. Write versions of tests with methods and configurations that intentionally generate error messages.</li>
<li>Analyze and plan test suites, learning how to balance the size and maintainability (ability to check failed tests) against the amount of features you want to test, as well as the level of abstraction you want to use to make modular objects to use in your test suite</li>
</ul>
<h2 is-upgraded>Base Code</h2>
<p>If you skipped Module 1, make sure you have a project folder set up and have created the following files, as well as have Maven, IntelliJ, and Junit installed</p>
<p class="image-container"><img alt="Directory Structure" style="width: 800.00px" src="img/2c674e4cbc171702.png"></p>
<h2 is-upgraded>Use GitHub Repository (Optional)</h2>
<p>If you are familiar with using GitHub to write your code, you can also fork/ branch this repository here for the first set of code:</p>
<p><a href="https://github.com/walkerlj0/Selenium_Course_Example_Code/blob/master/java/Mod1/1.06/src/test/java/companyname/TestLogin.java" target="_blank"><strong>Module 1 Project Folder</strong></a></p>


      </google-codelab-step>
    
      <google-codelab-step label="2.02 Writing Good Acceptance Tests" duration="10">
        <p>Acceptance tests are an important final step to take when releasing anything you may have designed, to make sure that the software you have created meets the requirements and specifications laid out when you designed and planned your application or platform. Automated testing is an integral tool to use to efficiently and accurately test your product for release.</p>
<p>In order to write automated web tests that are easy to maintain, perform well, and are ultimately resilient, there are some simple guidelines to follow:</p>
<ul>
<li>Write atomic and autonomous tests</li>
<li>Group like tests together in small batches</li>
<li>Be descriptive</li>
<li>Use a Test Runner</li>
<li>Store tests in a Version Control System</li>
</ul>
<h2 is-upgraded>Atomic &amp; Autonomous Tests</h2>
<p>Each test needs to be concise (e.g., testing a single feature rather than multiple features) and be capable of being run independently (e.g., sets up its own data rather than relying on a previous test to do it). <a href="https://wiki.saucelabs.com/display/DOCS/Best+Practices%3A+Use+Small%2C+Atomic%2C+Autonomous+Tests?utm_source=referral&utm_medium=LMS&utm_campaign=link" target="_blank">Learn more in the Sauce Cookbook</a>.</p>
<p>Doing this may require a mental shift, discipline, and more upfront effort, but it will make a dramatic impact on the quality, effectiveness, and maintainability of your tests, especially when you get into parallel test execution.</p>
<p class="image-container"><img alt="Atomic" src="img/661ab29424ea3dbc.png"></p>
<p>Image Source: <a href="https://medium.com/swlh/creating-fast-reliable-focused-ui-automation-with-atomic-tests-582e4318c0bb" target="_blank">Medium Article</a></p>
<h2 is-upgraded>Grouping Tests</h2>
<p>As your test suite grows, you will have numerous test files. Each file contains a group of tests that have similar functions. For example, you would have one directory for the files that are designed to locate and interact with the page, and another directory for files that perform tests (test to check if something does or does not happen when you interact).</p>
<h2 is-upgraded>Being Descriptive</h2>
<p>A test file should have a high level name that describes what the group of tests within it are doing. Each individual test with the test files should also have an informative name to describe the action each test is taking. In this case, descriptive names are better than concise names. Also, each test or grouping of tests should include some helpful tags or categories, which can provide additional information about the test as well as enable flexible test execution. This way, you can run all or part of your test suite, and the results will inform the tester what is being tested, as well as accurately identify what goes wrong.</p>
<p class="image-container"><img alt="Check" style="width: 150.00px" src="img/97c27b2115ad2b7.png"></p>
<p>This also enables developers to run a subset of tests to exercise functionality they just modified and enable you to use  a Continuous Integration (CI) server to run the right groups of tests at the right time for fast and dynamic feedback. It is helpful to be able to identify which tests you run when you only make changes to certain parts of an application. You may also want to have a subset of tests that is run regularly, on a nightly or weekly basis, to verify performance regularly, so using a certain category of tests for a regular test deployment can be helpful.</p>
<h2 is-upgraded>Test Runners</h2>
<p>At the heart of every test suite is some kind of a test runner like Mocha that does a lot of the heavy lifting such as test execution, centralized configuration, and test output. In this course, we will be using the Mocha test runner. Rather than reinvent the wheel, you can use one of the many test runners that exist today. With it you can bolt on third party libraries to extend its functionality if there&#39;s something missing.</p>
<h2 is-upgraded>Version Control</h2>
<p>In order to effectively collaborate with other testers and developers on your team, your test code must live in a version control system. Look to see what your development team uses and add your code to it. In the examples in this course, we will be providing code samples from GitHub.</p>
<h2 is-upgraded><a href="https://saucelabs.com/blog/a-two-minute-bdd-overview" target="_blank">BDD and TDD</a></h2>
<p>Behavior Driven Development and Test Driven Development are two important strategies to help you understand how to write effective tests. <a href="https://cucumber.io/blog/bdd/bdd-is-not-test-automation/" target="_blank">BDD</a> is a collaborative process that focuses on starting with a business value or need. It&#39;s a feature and epic-centric approach to create a requirements analysis. With both BDD and TDD, you plan to write the code for the test first (application code comes later).</p>
<p class="image-container"><img alt="Pencil" style="width: 150.00px" src="img/f06c14e85da7935b.png"></p>
<p><a href="https://saucelabs.com/blog/the-state-of-test-driven-development" target="_blank">TDD</a> is a more granular step that should be taken after a BDD plan is created. The general process involves writing a failing test for particular features (determined previously with the BDD process), then the developer writes the code to lead to a successful run of this test. The goal is to be able to write failing tests that can be turned into a passing test with minimal code modification, and no change to dependencies, base pages, or configuration files.</p>


      </google-codelab-step>
    
      <google-codelab-step label="2.03 Defining a Test Strategy and Picking a Framework." duration="5">
        <p>A great way to increase your chances of success with automated web testing is to first map out a testing strategy. The best way to do it is to answer these four questions:</p>
<ul>
<li><em>How does your business make money?</em></li>
<li><em>What features in your application are being used?</em></li>
<li><em>What browsers are your users using?</em></li>
<li><em>What things have broken in the application before?</em></li>
</ul>
<p class="image-container"><img alt="npm init" style="width: 200.00px" src="img/87b188751749832b.png"></p>
<h2 is-upgraded>What to Do with the Answers</h2>
<p>After answering these questions, you should end up with a prioritized punch list or backlog of test automation tasks that you can choose tasks from, and track progress against.</p>
<h3 is-upgraded>Question 1: What is the Value?</h3>
<p>Every company&#39;s application makes money (or generates value) through core functionality that is defined by a series of increasingly-valuable user interactions known as a &#34;funnel&#34;. Your answers to this question will help you determine what your funnel is.</p>
<p>These items will be your highest priority for automation. Start an automation backlog to keep track of them.</p>
<h3 is-upgraded>Question 2: What Does Usage Data Say?</h3>
<p>Odds are your application offers a robust set of functionality well beyond your funnel. Your answers to this question will help highlight what it is. And if you&#39;re basing these answers on usage data like those obtained from Google Analytics, then you can see which features and functionality are more frequently used than others.</p>
<p>When you data shows certain functions, features, and flows are frequently used, consider adding them as a priority for your automated testing suite.</p>
<h3 is-upgraded>Question 3: Which Browsers?</h3>
<p>Now that you know what functionality is business critical and widely adopted by your users, you need to determine what browsers to focus your automated web testing efforts on. Your usage data will tell you this as well. It will help you determine which browsers you can reasonably avoid testing in (based on non-existent or low usage numbers).</p>
<p>Note the top 2 (or 3 depending on your numbers), but focus on the top 1 for now. This is the browser you will start using for automation.</p>
<h3 is-upgraded>Question 4: What are the Risky Bits?</h3>
<p>To round out the strategy, it is also best to think about what things have broken in the application before. To answer this question, it&#39;s best to check your defect/bug tracker (if you have one) and to ask your team. What you end up with may read like a laundry list of browser specific issues or functionality that has been flaky or forgotten about in the past. But it&#39;s all useful information.</p>
<p>Be sure to check this list against your automation backlog. If something&#39;s not there, add it to the bottom of the backlog. If it is there, make a note in the backlog item that it has been an issue in the past.</p>
<p>If the issue has happened numerous times and has the potential to occur again, move the item up in the backlog. And if issues keep cropping up that are related to a specific browser, compare this browser to your short list of browsers from question #3. If it&#39;s a browser that&#39;s not in your list but it&#39;s still important (e.g., a small pocket of influential users), track it on the backlog, but put it at the bottom.</p>
<h2 is-upgraded>Now You are Ready</h2>
<p>Having answered these questions, you should now have a prioritized backlog of critical business functionality, a short list of browsers to focus on, and an understanding of the risky parts of your application to watch out for. With it, you&#39;re on the right track — focusing on things that matter for your business and its users.</p>


      </google-codelab-step>
    
      <google-codelab-step label="2.04 Finding &amp; Testing Locators in the Browser" duration="15">
        <h2 is-upgraded>How to Find Locators</h2>
<p>The simplest way to find locators is to inspect the elements on a page. The best way to do this is from within your web browser. Fortunately, popular browsers come pre-loaded with development tools that make this simple to accomplish.</p>
<p>When viewing the page, right-click on the element you want to interact with and click <strong>Inspect Element</strong>. This will bring up a small window with all of the markup for the page but zoomed into your highlighted selection. From here, you can see if there are unique or descriptive attributes you can work with.</p>
<p class="image-container"><img alt="npm init" style="width: 200.00px" src="img/d6c9d80cbb15841.png"></p>
<p>If you&#39;re fortunate enough to be working with unique IDs and classes, then you&#39;re usually all set. But when you have to handle more complex actions like traversing a page, or you need to run down odd test behavior, it can be a real challenge to verify that you have the right locators to accomplish what you want.</p>
<h3 is-upgraded>Video</h3>
<p>Watch <a href="https://www.youtube.com/watch?v=l_oOa7LeHqI&feature=youtu.be" target="_blank">Finding Locators with Dev tools</a> on using locators and follow along in your browser.</p>
<iframe class="embedded-iframe" src="https://drive.google.com/file/d/1UkrnRcfnjurdlTiFAHSvpvohy5wdj9FF/preview"></iframe>
<p>Use the following notes to help you use the inspector to test elements. Later you will test elements with your code. You can use the webpage here to follow along:</p>
<p><a href="https://www.saucedemo.com/" target="_blank"><strong>https://www.saucedemo.com/</strong></a></p>
<h3 is-upgraded>Locator Strategies</h3>
<p class="image-container"><img alt="Locator Table" src="img/cf55e0fbd34e29db.png"></p>
<p>Find more on <a href="https://yizeng.me/2014/03/23/evaluate-and-validate-xpath-css-selectors-in-chrome-developer-tools/" target="_blank">XPath here</a></p>
<h2 is-upgraded>How to Find Quality Elements</h2>
<p>You want to find an element that is unique, descriptive, and unlikely to change.</p>
<p>Ripe candidates for this are <code>id</code> and <code>class</code>attributes. Whereas text (e.g., the text of a link) is less ideal since it is more apt to change. If the elements you are attempting to work with don&#39;t have unique <code>id</code> or <code>class</code> attributes directly on them, look at the element that houses them (a.k.a. the parent element). Oftentimes the parent element has a unique element that you can use to start with and walk down to the child element you want to use.</p>
<p>When you can&#39;t find any unique elements have a conversation with your development team letting them know what you are trying to accomplish. It&#39;s typically a trivial thing for them to add helpful semantic markup to a page to make it more testable. This is especially true when they know the use case you&#39;re trying to automate. The alternative can be a lengthy and painful process which might yield working test code but it will be brittle and hard to maintain.</p>
<p>Once you&#39;ve identified the target elements and attributes you&#39;d like to use for your test, you&#39;ll need to craft locators using one of Selenium&#39;s strategies.</p>
<p>Selenium is able to find and interact with elements on a page by way of various locator strategies. The list includes (sorted alphabetically):</p>
<ul>
<li>Class  in the HTML</li>
<li>CSS Selector</li>
<li>ID</li>
<li>Link Text</li>
<li>Name</li>
<li>Partial Link Text</li>
<li>Tag Name</li>
<li>XPath</li>
</ul>
<h2 is-upgraded>Quiz</h2>
<iframe class="embedded-iframe" src="https://docs.google.com/forms/d/e/1FAIpQLSevoUGKLiahuRG42j_PfGchc8Qama_MSAg6FkiPbkKssSnU2g/viewform?embedded=true"></iframe>


      </google-codelab-step>
    
      <google-codelab-step label="2.05 Setting Up Your First Test" duration="15">
        <p>Here&#39;s the markup for a standard login form (pulled from the login example app on <a href="http://the-internet.herokuapp.com/login" target="_blank">the-internet</a>.</p>
<p class="image-container"><img alt="Login Page" src="img/4c5360db0f2f09c4.png"></p>
<pre><code>&lt;form name=&#34;login&#34; id=&#34;login&#34; action=&#34;/authenticate&#34; method=&#34;post&#34;&gt;
     &lt;div class=&#34;row&#34;&gt;
          &lt;div class=&#34;large-6 small-12 columns&#34;&gt;
              &lt;label for=&#34;username&#34;&gt;Username&lt;/label&gt;
              &lt;input type=&#34;text&#34; name=&#34;username&#34; id=&#34;username&#34;&gt;
          &lt;/div&gt;
     &lt;/div&gt;

    &lt;div class=&#34;row&#34;&gt;
        &lt;div class=&#34;large-6 small-12 columns&#34;&gt;
            &lt;label for=&#34;password&#34;&gt;Password&lt;/label&gt;
            &lt;input type=&#34;password&#34; name=&#34;password&#34; id=&#34;password&#34;&gt; &lt;/div&gt;
        &lt;/div&gt;
            &lt;button class=&#34;radius&#34; type=&#34;submit&#34;&gt;&lt;i class=&#34;icon-2x    
             icon-signin&#34;&gt; Login&lt;/i&gt;
            &lt;/button&gt;
&lt;/form&gt;


</code></pre>
<p>Notice the element attributes on the form. The username input field has a unique<code>id</code>, as does the password input field. The submit button doesn&#39;t, but it&#39;s the only button on the page so we can easily find it and click it.</p>
<p>Let&#39;s put these elements to use in our first test.</p>
<h2 is-upgraded>Setup Your Project File</h2>
<p>First we will need to create a new project directory called <code>Selenium??</code> (your main project directory), and inside create a folder named <code>test</code> inside that project directory. This is a default folder that Mocha will know to look for.</p>
<p>You can see all of the files here.</p>
<p><strong>_</strong><a href="https://github.com/walkerlj0/Selenium_Course_Example_Code/tree/master/java/Mod2/2.05" target="_blank"><strong>Selenium_Course_Example_Code </strong></a><strong>_</strong></p>
<h2 is-upgraded>NOTE</h2>
<p>If you are a first-time user of IntelliJ with Java, I highly recommend checking out the YouTube channel by JetBrains. <a href="https://www.youtube.com/watch?v=H_XxH66lm3U" target="_blank">This is a great first video.</a></p>
<p>–</p>
<p>If you pull down a project file from Github instead of creating it as outlined below, and want to test it on your machine, you will have to use IntelliJ to set up your environment with Maven to manage your files and specify which Java Development Kit (aka Software Development Kit)  you use (both of these should be installed on your computer ahead of time). If you download the source code, first open the project.</p>
<p>If you pull down a project file from Github instead of creating it as outlined below, and want to test it on your machine, you will have to use IntelliJ to set up your environment with Maven to manage your files and specify which Java Development Kit (aka Software Development Kit)  you use (both of these should be installed on your computer ahead of time). If you download the source code, first open the project.</p>
<p>Go to File → <strong>Add Framework Support</strong>.</p>
<p class="image-container"><img alt="Add framework Support" style="width: 350.00px" src="img/568714aa74cf11cd.png"></p>
<p>Choose <strong>Maven</strong> and click <strong>OK</strong>.</p>
<p class="image-container"><img alt="Maven OK" style="width: 350.00px" src="img/790d1910e31fd10a.png"></p>
<p>Next, set up the SDK used to compile your Java code. Go to <strong>File → Project Structure</strong>.</p>
<p class="image-container"><img alt="Project structure" style="width: 350.00px" src="img/f4aa606c5cbd450.png"></p>
<p>Under <strong>Project Settings</strong>, choose <strong>Project</strong>, then choose your SDK in the dropdown menu. You should see the SDK</p>
<p class="image-container"><img alt="Choose SDK" style="width: 450.00px" src="img/e9ebed436508e4ba.png"></p>
<p>–</p>
<h2 is-upgraded>Installing Chromedriver</h2>
<p>In order for your test to run on a browser on your local machine, you need to install the driver for the browser, and update your code. A similar set of steps can be followed for any browser.</p>
<p>First, check which version of chrome you are using by opening Chrome on your machine and checking the version.</p>
<p class="image-container"><img alt="Chrome Version" style="width: 550.00px" src="img/2c3b17376edacaf1.png"></p>
<p>Next, (download the Chromedriver)<a href="you can also download (Geckodriver" target="_blank">https://chromedriver.chromium.org/downloads</a>[https://github.com/mozilla/geckodriver] for Firefox or (any other driver)[https://automationintesting.com/selenium/java/lessons/drivers.html] you will need for popular browsers) The driver version should match the version of the browser you have on your machine.</p>
<h2 is-upgraded>NOTE</h2>
<p>If you are testing on an older version of Firefox (e.g., 47 or earlier) then you don&#39;t need to download Geckodriver. You will be able to use the legacy FirefoxDriver implementation. To do that you just need to disable Marionette (the new Firefox WebDriver implementation that Geckodriver connects to) which would look like this:</p>
<p><code>System.setProperty(&#34;webdriver.firefox.marionette&#34;, &#34;false&#34;);</code></p>
<p>–</p>
<p>Download the file, then unzip it and move it somewhere outside of your downloads folder. Here, I chose to move it inside of the Documents folder.</p>
<p class="image-container"><img alt="Driver Folder" style="width: 550.00px" src="img/ea4cc802b6a49d36.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="2.06 Create Your Project File" duration="15">
        <p>Now we are ready to start writing the code for your first test. Create a new project directory called <strong>SeleniumJava</strong> (in your main project directory on your computer), and inside create the directory <strong>java</strong>. This is a default folder that Maven will know to look for.</p>
<p>Inside of your Java file create a folder with your company name. Mine is named <strong>companyname.</strong> Inside of that create a file called <strong>TestLogin.java</strong>.</p>
<p class="image-container"><img alt="Directory Structure" style="width: 350.00px" src="img/dfbb98e672764567.png"></p>
<p>Copy and paste the following code into the file:</p>
<pre><code>//filename: tests/TestLogin.java
package companyname;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.chrome.ChromeOptions;

import static org.junit.Assert.assertTrue;

public class TestLogin {

    private WebDriver driver;

    @Before
    public void setUp() {
        System.setProperty(&#34;webdriver.chrome.driver&#34;,   
        &#34;&lt;insert filepath to chromedriver here&gt;&#34;);
          ChromeOptions browserOptions = new ChromeOptions();
          driver = new ChromeDriver();
    }

    @Test
    public void succeeded() {
        driver.get(&#34;http://the-internet.herokuapp.com/login&#34;);
        driver.findElement(By.id(&#34;username&#34;)).sendKeys(&#34;tomsmith&#34;);
        driver.findElement(By.id(&#34;password&#34;)).sendKeys(&#34;SuperSecretPassword!&#34;);
        driver.findElement(By.cssSelector(&#34;button&#34;)).click();
        assertTrue(&#34;success message not present&#34;,
                driver.findElement(By.cssSelector(&#34;.flash.success&#34;)).isDisplayed());
    }

    @After
    public void tearDown() {
        driver.quit();
    }
}



</code></pre>
<h2 is-upgraded>NOTE</h2>
<p>The two imported classes may delete themselves or turn grey – the IntelliJ IDE will intentionally clean up code and remove the import of unnecessary classes to speed up the running of your code.</p>
<p class="image-container"><img alt="Chrome Version" style="width: 550.00px" src="img/d9b379bfd8c8c4d8.png"></p>
<p>–</p>
<p>The top of the file is where the dependencies go. In order for the instantiation of Selenium to work with Firefox, we need to specify the path to the Chromedriver we downloaded into the vendor directory.</p>
<p>Here you will notice JUnit annotations being imported, as well as the Selenium and Chrome drivers.</p>
<p>After importing the drivers and tools classes for JUnit and Selenium we create a class, <code>public class TestLogin {}</code>,  and declare a field variable to store and reference an instance of Selenium WebDriver, <code>private WebDriver driver;</code>.</p>
<h2 is-upgraded>@Before and @After Annotations</h2>
<p>After creating the class, we add setup and teardown methods using what is known as annotations, using <code>@Before</code> and <code>@After</code>. In them we&#39;re creating an instance of Selenium (storing it in driver) and closing it with <code>driver.quit();</code>. Thanks to the <code>@Before</code> annotation, the<code>public void setUp()</code> method will load before the test and the <code>@After</code> annotation will make the <code>public void tearDown()</code> method load after the test.</p>
<p>This abstraction using the JUnit annotations library enables us to write our test with behavior we want to exercise in the browser, rather than clutter it up with setup and teardown details written in Java.</p>
<h2 is-upgraded>NOTE</h2>
<p>If you notice that some of the dependencies at the top are red, it means you need to install those dependencies. Refer to module 1.05 Video on <a href="https://drive.google.com/file/d/1Xg9Rn-R5Y-924yEpA6GW5YzB_-dxzS3x/view?usp=sharing" target="_blank">using IntelliJ to install dependencies</a>, and the <a href="https://docs.google.com/document/d/1FTSxen0sm_3pXERqfVb3txc5f22HyclKeTbeFFbhM9M/edit?usp=sharing" target="_blank">Cheat Sheet </a>for web drivers.</p>
<p>We&#39;re able to do this by specifying a system property with <code>System.setProperty(&#34;webdriver.chrome.driver&#34;)</code> and providing the full path to the file which we find by using the project directory path and appending /vendor/geckodriver to it.</p>
<p>–</p>
<h3 is-upgraded>Cheat Sheet</h3>
<p><a href="https://docs.google.com/document/d/1FTSxen0sm_3pXERqfVb3txc5f22HyclKeTbeFFbhM9M/edit?usp=sharing" target="_blank">2.05 Driver Configuration</a></p>
<h2 is-upgraded>Run a Test with IntelliJ</h2>
<p>IntelliJ is a comprehensive tool that allows you to work with Maven, JUnit, Github, and many other dependencies all from the same window. It allows you to debug and run portions of a test, see which branch you are on in Github, manage project files, and much more. If you aren&#39;t familiar, you can <a href="https://www.jetbrains.com/help/idea/guided-tour-around-the-user-interface.html" target="_blank">learn more here</a>.</p>
<h3 is-upgraded>Video</h3>
<p>Follow the instructions here in <a href="https://drive.google.com/file/d/1FlQ75pcOR37FEMCPKQEk6SeihA6d_Z1f/view?usp=sharing" target="_blank">2.05_IntelliJ_Tests</a> to learn how to run a test with the IntelliJ UI</p>
<iframe class="embedded-iframe" src="https://drive.google.com/file/d/1FlQ75pcOR37FEMCPKQEk6SeihA6d_Z1f/preview"></iframe>


      </google-codelab-step>
    
      <google-codelab-step label="2.07 Test Assertions" duration="10">
        <p>Assertions are statements that are used at a certain point in the test code (usually following a certain sequence of events) that check to see if some condition is true or false. The test code you created thus far simply tells your test what elements to look for on the page, and what to do with those elements.</p>
<h2 is-upgraded>Add an Assertion</h2>
<p>Now it&#39;s time to add in an assertion to see if your actions had the desired effect. We want to check that the div that pops up when you have successfully logged in with the <code>class = &#34;flash_success&#34;</code>does in fact appear after you enter the login credentials.</p>
<p class="image-container"><img alt="Pencil" style="width: 400.00px" src="img/e927da2d1f4b1494.png"></p>
<p>Start by opening the blank <code>TestLogin.java</code> file you created in the <code>tests</code> directory.</p>
<p>Copy and paste the following code into your program file, between the <code>@Before</code> and <code>@After</code>Assertions.</p>
<pre><code>//filename: tests/TestLogin.java
package companyname;

import static org.junit.Assert.assertTrue;

//...
public class TestLogin {
    private WebDriver driver;
    @Before
// ...
    @Test
    public void succeeded() {
        driver.get(&#34;http://the-internet.herokuapp.com/login&#34;);
        driver.findElement(By.id(&#34;username&#34;)).sendKeys(&#34;tomsmith&#34;);
        driver.findElement(By.id(&#34;password&#34;)).sendKeys(&#34;SuperSecretPassword!&#34;);
        driver.findElement(By.cssSelector(&#34;button&#34;)).click();
        assertTrue(&#34;success message not present&#34;,
                driver.findElement(By.cssSelector(&#34;.flash.success&#34;)).isDisplayed());
    }

    @After
//...

</code></pre>
<h2 is-upgraded>NOTE</h2>
<p>When using the IntelliJ IDE, classes and libraries must be instantiated within the code before they can be added to the list of imported elements at the top. Watch this video (gif?) to see how this is done.</p>
<h3 is-upgraded>Video</h3>
<p>Importing Classes and Methods with IntelliJ</p>
<p class="image-container"><img alt="Pencil" style="width: 800.00px" src="img/7b898f75b5c2cb38.gif"></p>
<p>–</p>
<p>Our test is a method as well, <code>public void succeeded()</code>. JUnit knows this is a test because of the <code>@Test</code> annotation. In this test we&#39;re visiting the login page by it&#39;s URL with <code>driver.get();</code>,finding the input fields by their ID with <code>driver.findElement(By.id()</code>), sending them text with <code>.sendKeys(); ,</code>and submitting the form by clicking the submit button <code>with By.cssSelector(&#34;button&#34;)).click();</code>.</p>
<p>If we save this and run it ( <code>mvn clean test</code> from the terminal), it will run and pass. But there&#39;s one thing missing – an assertion. In order to find an element to make an assertion against, we need to see what the markup is after submitting the login form.</p>
<p>First, we had to import the JUnit assertion class. By importing it as static we&#39;re able to reference the assertion methods directly (without having to prepend Assert.). Next we add an assertion to the end of our test.</p>
<p>With <code>assertTrue</code> we are checking for a true (Boolean) response. If one is not received, a failure will be raised and the text we provided (<code>&#34;success message not present&#34;</code>) will be displayed in the failure output. With Selenium we are seeing if the success message is displayed with <code>.isDisplayed()</code>. This Selenium command returns a true or false value. So if the element is visible in the browser, true will be returned, and our test will pass.</p>
<h2 is-upgraded>NOTE</h2>
<p>If you find that your tests are failing, try running the command <code>source ~/bash_profile</code>(or <code>source ~/.zhsrc</code>for MacOS Catalina) in the command line. This tells your machine to look at your bash profile to find the path to Maven and other dependencies.</p>
<p>In order to avoid doing that each time, you can edit your profile with the following steps:</p>
<ol type="1">
<li>In terminal, run <code>cd ..</code>and hit enter until you are at the top directory</li>
<li>Once you are in the top directory, run the command <code>ls</code>, and you should see a directory named <code>/bin</code></li>
<li>Run <code>cd bin</code> to enter that directory and run<code>ls</code> again. In that list of files, you should see one called profile. Open it in edit mode by running the command<code>sudo vi profile</code>(you may have to enter your password)</li>
<li>Type <code>i</code>to enter insert mode. Next, copy and paste in <code>source ~/bash_profile</code>in the second line of code. Hit escape twice, then you should be able to type in <code>:wq!</code> At the bottom to save the changes. Now your machine knows where to look for your environment and PATH variables</li>
</ol>
<p class="image-container"><img alt="Bash Profile" style="width: 450.00px" src="img/e86df547f6cfbc1f.png"></p>
<p>–</p>
<h2 is-upgraded>Run Your Code</h2>
<p><a href="https://drive.google.com/file/d/1FlQ75pcOR37FEMCPKQEk6SeihA6d_Z1f/view?usp=sharing" target="_blank">See Video</a></p>
<iframe class="embedded-iframe" src="https://drive.google.com/file/d/1FlQ75pcOR37FEMCPKQEk6SeihA6d_Z1f/preview"></iframe>
<h2 is-upgraded>Test Your Code with a Failure</h2>
<p>Just to make certain that this test is doing what we think it should, let&#39;s change the assertion to force a failure and run it again. A simple fudging of the locator will suffice.</p>
<pre><code>      assertTrue(&#34;success message not present&#34;,
                driver.findElement(By.cssSelector(&#34;.flash.successasdf&#34;)).isDisplayed());


</code></pre>
<p>If it fails, then we can feel confident that it&#39;s doing what we expect, and can change the assertion back to normal before committing our code. If it doesn&#39;t fail, it could mean a successful test is a ‘false positive&#39; where our test will indicate, say successful location of an element, even if that element wasn&#39;t located.</p>
<p>This is a key debugging strategy, and for each test you create, you should check to make sure you can run a failed test each time by entering unexpected or incorrect values.</p>
<h2 is-upgraded>Final Code</h2>
<p class="image-container"><img alt="Final Test Code" style="width: 650.00px" src="img/d35c985c4559d0db.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="2.08 Verifying Locators with Selenium" duration="15">
        <p>Selenium uses locators to find elements on the page and interact with them.</p>
<p>Instead of the painful and tedious process of trying out various locators in your tests until you get what you&#39;re looking for, try verifying them in the browser instead.</p>
<p>Once you have identified a class, id, name, link text, Xpath, etc. for an element, you can use the Selenium <code>findElement()</code>method along with the driver object in your Java test code.</p>
<p>In this exercise we can create a similar test using another page from the _the-internet _app called</p>
<p><a href="https://github.com/walkerlj0/Selenium_Course_Example_Code/tree/master/java/Mod2/2.07" target="_blank"><strong>Challenging DOM</strong></a></p>
<p>Next, we will create a new test file, named <code>TestLocator.java.</code> Place it in the same ‘test&#39; folder as the other test we created:</p>
<p class="image-container"><img alt="TestLocator" style="width: 350.00px" src="img/2ee28c1b2ef65379.png"></p>
<h3 is-upgraded>NOTE</h3>
<p>This can be done in IntelliJ by right clicking within the **companyname <strong>folder in the project window and creating a</strong> New → Java Class **then naming it <strong>TestLocator.</strong></p>
<p class="image-container"><img alt="New Java Class" style="width: 650.00px" src="img/93b868e6f30dba06.png"></p>
<p class="image-container"><img alt="Test Locator Class" style="width: 350.00px" src="img/76824e80260fe343.png"></p>
<p>–</p>
<p>Copy and paste the code below into your test file.  Above the <code>public class {}</code> declaration, you will <code>import</code> all of your dependencies. You will also instantiate the driver, then create the code to set up, test, then tear down your test within the <code>@Before, @Test, and @After</code>code.</p>
<pre><code>// filename: test/TestLocator.java

//filename: tests/TestLogin.java
package companyname;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.chrome.ChromeOptions;

public class TestLocator {

    private WebDriver driver;

    @Before
    public void setUp() {
        System.setProperty(&#34;webdriver.chrome.driver&#34;, &#34;/Users/lindsaywalker/Documents/chromedriver&#34;);
        ChromeOptions browserOptions = new ChromeOptions();
        driver = new ChromeDriver(/*browserOptions*/);
    }

    @Test
    public void locator_test() {
        driver.get(&#34;http://the-internet.herokuapp.com/challenging_dom&#34;);
//        driver.findElement(By.id(&#34;    &#34;)).click();
//        driver.findElement(By.id(&#34;&#34;)).click();

        // Return the text of the red button id=button alert contains &#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;, or &#39;qux&#39;
        String output = driver.findElement(By.cssSelector(&#34;.button.alert&#34;)).getText();
        System.out.println(&#34;The button reads: &#34; + output);

}

    @After
    public void tearDown() {
        driver.quit();
    }
}



</code></pre>
<p>You challenge, should you choose to accept it, is to add the locator</p>
<ol type="1">
<li>Navigate to <a href="https://the-internet.herokuapp.com/challenging_dom" target="_blank">https://the-internet.herokuapp.com/challenging_dom</a> and right click on a button to open the inspector.</li>
<li>Use the inspector to locate and test finding elements. In this test we are going to click the green button, then the blue button, and then check to see what is on the red button at the end.</li>
</ol>
<h3 is-upgraded>Video</h3>
<p>Watch the video below to understand how the LocatorTest works:</p>
<iframe class="embedded-iframe" src="https://drive.google.com/file/d/1ECOPFiEMSrvUGOq9GAxs5YHNvZAlpTYz/preview"></iframe>
<h3 is-upgraded>Cheat Sheet</h3>
<p><a href="https://docs.google.com/document/d/1M0_TKpk_N3U3OOB3EUHEsxRC1TJQPPYwLfA0ZmohqcU/edit?usp=sharing" target="_blank">2.08 Selenium Locators Cheat Sheet</a></p>
<ol type="1">
<li>Your test should test clicking first the green button, then the blue button, then check to make sure both have been clicked (Check CSS/ id). Using the code above, complete and run the test.  This is not a typical functional test, as there is no assertion, but we do return a value.</li>
<li>Use the documentation here on using the<a href="https://github.com/saucelabs-training/advanced-selenium/blob/charlotte/src/docs/locators.md" target="_blank"> By Selenium class </a>to figure out how to complete the code. You can also use the <a href="https://docs.google.com/document/d/1tDS_M9ltC73Ghii1WdKzuH2PAAAo0kLk1JsGuyqJjNA/edit?usp=sharing" target="_blank">Cheat Sheet</a> to help.</li>
</ol>
<p class="image-container"><img alt="Locators Code" style="width: 550.00px" src="img/be1b21c41d440771.png"></p>
<ol type="1">
<li>If you were successful, you should see both the locator and login tests (both are in the test folder) run, and below your locator, you should see the text that appeared on the red button when it was run:</li>
</ol>
<p class="image-container"><img alt="Locators Success" style="width: 550.00px" src="img/c351dd78af48419f.png"></p>
<p>See the complete <a href="https://github.com/walkerlj0/Selenium_Course_Example_Code/tree/master/java/Mod2/2.07_solution" target="_blank">source code here</a>.</p>


      </google-codelab-step>
    
      <google-codelab-step label="2.09 Module 2 Quiz" duration="5">
        <iframe class="embedded-iframe" src="https://docs.google.com/forms/d/e/1FAIpQLSe-_eb_bCY1dd9pNXrbAFL4Zrc-vl1DIrTinGazhYTpBKvJww/viewform?embedded=true"></iframe>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
