
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Module 4 – Scaling Tests to the Cloud</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid="UA-6735579-1"
                  id="../site/codelabs/Module4_SeleniumJava"
                  title="Module 4 – Scaling Tests to the Cloud"
                  environment="web"
                  feedback-link="https://forms.gle/CGu4QchgBxxWnNJK8">
    
      <google-codelab-step label="4.01 What You&#39;ll Learn" duration="3">
        <p>This module is derived from content in chapters 11-13 of <em>The Selenium Guidebook Java Edition</em> By Dave Haeffner._ _This module guides you through creating a separate <code>BaseTest</code> file where the root level <code>before()</code>and<code>after()</code> hooks will live for each test, as well as a _Driver Factory _which creates the <code>build()</code> and <code>quit()</code> functions used for each instance of a test.  Users will work through creating a config file to store the environment variables specifying in which environment your test is run, and modify the base page to check &amp; pull environment variables from config. Last but not least, add in some features to make your tests&#39; results easier to read and debug using the Sauce Labs platform.</p>
<h2 is-upgraded>Objectives</h2>
<ul>
<li>** **Analyze and plan test suites, learning how to balance the size and maintainability (ability to check failed tests) against the amount of features you want to test, as well as the level of abstraction you want to use to make modular objects to use in your test suite</li>
<li>Learn about the different categories and types of tests. Understand which types of functional tests one uses Selenium for and how the different types and categories of tests are related</li>
<li>Learn about <em>Root Level Hooks</em> that handle the universal rules  <code>before()</code>and <code>after()</code>that all tests use, and that you can separate the common functionality that all tests use with these methods in a separate file (such as <code>BaseTest.java</code>) to be used with each test</li>
<li>Understand how to create a file that configures a test environment, and how it is used with <code>BaseTest</code> and<code>BasePage</code> objects to create a template from which each test is built</li>
<li>Identify and fix problems in test suites such as poor locators, silent failures, and too much functionality in a single class</li>
<li>Choose and separate imperative language into separate objects and pages, and use the simplified commands created in that class with other tests to write code that is easier to read, maintain, and declarative in nature</li>
<li>Create a <br><code>BaseTest</code> that creates all of the <code>before()</code> and <code>after()</code> functionality each test uses to spin up and tear down a test</li>
<li>Create a <code>Config</code> file that sets the W3C<em> capabilities </em>for <code>BaseTest</code> to set up the environment for each, which set up variables for the environment, that dictate what your test is run in.</li>
<li>Set up a <code>baseURL</code> variable in <code>Config</code> that points to the app you are running tests on in the <code>BasePage</code>, and remove hard-coded URLs from other page objects, allowing you to specify just a sub-domain from page objects</li>
<li>Update your Sauce Labs credentials on your machine, then add functionality in your config file, using the sauceOption capabilities to run your tests on Sauce Labs</li>
<li>Add variables and logic to your <code>BaseTest</code> to pass information such as the test name, and pass or failure status to the Sauce Labs dashboard</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="4.02 Types of Tests" duration="5">
        <p>In testing, both automated and manual, there are several different types of tests. Not all types of tests are mutually exclusive. For example, when doing regression testing, you may use unit tests, and unit tests can be used as a piece for an integration test.</p>
<h2 is-upgraded>Functional vs Non-Functional Tests</h2>
<p>These two types of tests are ways to categorize tests by what they are testing. Functional tests check to see if a feature is or is not working, nothing more (e.g. did I log in or not log in?). Non-functional testing typically helps measure how much and how well an application is performing, enabling <strong>performance testing</strong> that helps teams understand and predict whether the software and features will work as expected, at scale. An example would be load testing, to see if the test runs as expected with many simultaneous users or volume testing.  <a href="https://accounts.saucelabs.com/am/XUI/#login/?utm_source=referral&utm_medium=LMS&utm_campaign=link" target="_blank">Sauce Labs </a>  does front-end functional testing, as well as non-functional testing.</p>
<p class="image-container"><img alt="DDOS Attack" style="width: 450.00px" src="img/1c3be118ef09c1b4.gif"></p>
<p>Source <a href="https://imgur.com/Ksjm2D3" target="_blank">imgur</a></p>
<p>Selenium is most used for functional testing using a browser. Types of functional tests include unit testing, UI testing, regression testing, integration testing, and more.</p>
<h2 is-upgraded>Unit Tests</h2>
<p>Unit tests are the smallest, simplest possible type of test you can do. They test one single action on one single page/ application, and nothing more. Often these tests are written and executed on your local machine to validate that each ‘piece&#39; of a more complex test works.</p>
<p>The typical structure for a unit test is:</p>
<ol type="1">
<li>Set up the test data. (Given &#34;x&#34; condition&#34;.)</li>
<li>Call the class you are testing. (When &#34;y&#34; behavior happens.)</li>
<li>Assert that the expected results are returned. (Then &#34;z&#34; expected change is returned.)</li>
</ol>
<h2 is-upgraded>Integration Tests (Service Tests)</h2>
<p>Much of the time, when you write test code, it&#39;s not just one application you are testing, but many. As an example, if you were to sign up for Netflix, you would have to sign up on their website, send and receive information from their user management software (store user information to a database), as well as send and receive information from the software that processes their payments. Integration tests if and how these different services function together as a whole.</p>
<p>Many times integration tests can be formed from groups of unit tests. You can think of an integration as combining API tests with unit and UI tests to test how the entire service works.</p>
<h2 is-upgraded>UI Tests</h2>
<p>A UI Test is a test of the visual interface a human user would interact with. Selenium is very well suited to these kinds of tasks.  You can test the layout and behavior of a test easily, as well as track the usability of user flows. Many times the UI test can give insight into if an app is functioning on other layers. As an example, if you see an ‘error message&#39; in the UI when you log in, you can tell that something went wrong when trying to submit the username and password for authentication.</p>
<h2 is-upgraded>Regression Tests</h2>
<p>A specific set of tests that verify that the changes being made (new features) don&#39;t break your application. Regression testing is more of a methodology than a specific way to write a test. These tests can include unit and integration tests, but the difference here is this set of tests is created with the purpose of checking to make sure a change doesn&#39;t break the application.</p>
<h2 is-upgraded>End-to-End Tests</h2>
<p>Similar to system testing, E2E tests can include just following a user&#39;s workflow in a visual interface, or include everything that occurs in an application environment, creating a situation that mimics real-world use. This includes actions such as interacting with a database, using network communications, or interacting with other hardware, applications, or systems if appropriate along a specific user flow.</p>
<h2 is-upgraded>Black Box vs. White Box Testing</h2>
<p>White Box testing is a type of testing you do when you can see and understand all of the inner workings of an application and it&#39;s source code. Black Box testing is testing that is done from the end-user perspective, without any knowledge of the internal structure of application code. A good example of this is testing a workflow on the user interface of a web application. It is reasonable to assume for a login test, that if you enter the correct username and password, click submit, then get access to the platform, that the code for making this happen on the back end is also working.</p>
<h2 is-upgraded><a href="https://saucelabs.com/blog/headless-browser-testing-101" target="_blank">Headless Testing</a></h2>
<p>This type of testing refers to a code-based approach to testing web applications. When a human user is manually testing an application, they are looking at the visual browser interface with items you can see, click, and interact with. Headless testing is done by a robot that doesn&#39;t use the visual component of a browser, and instead does all interactions through communication with the codebase and other services that make up an application. <a href="https://accounts.saucelabs.com/am/XUI/#login/?utm_source=referral&utm_medium=LMS&utm_campaign=link" target="_blank">Sauce Labs </a> also provides headless user testing.</p>


      </google-codelab-step>
    
      <google-codelab-step label="4.03 Scaling Your Tests" duration="20">
        <p>Now that you have some tests and page objects, we&#39;ll want to start thinking about how to structure our test code to be more flexible and maintainable. Ensuring that our code is reusable, and can scale to as many tests as you need, requires some additional elements &amp; abstractions.</p>
<p>In a test suite, when you specify before and after hooks outside of a test class they are used globally for all tests. These are referred to as_ root-level hooks_. Every test that you write will use the <code>before()</code> and<code>after()</code>methods to perform the same set of actions to set up and tear down the test, so it makes sense to store these in one place so you can make changes in one place, instead of within each and every test.</p>
<h2 is-upgraded>Part 1: Root Level Hooks</h2>
<p>We&#39;ll start by using a separate class for Selenium setup and teardown out of our tests, placing the file in a central directory.</p>
<p>We&#39;ll create three things.</p>
<ul>
<li>A class that will contain the creation and destruction of our Selenium instances (known as a <em>Base Test</em>)</li>
<li>A helper that all tests will pull from to do the basic things each test should do such as <code>before()</code> and <code>after()</code>from the Junit <code>ExternalResource</code> rul<code>e</code>  <ul>
<li>These will be annotated with<code>@Override</code>which will execute prior to the<code>@Before</code> and<code>@After</code>annotations in individual tests</li>
</ul>
</li>
<li>Update your login and dynamic loading tests to inherit from the base class and utilize the setup and teardown from within the base class</li>
</ul>
<p>Create a new class in the tests project names BaseTest.java.</p>
<p class="image-container"><img alt="Add Base Test" style="width: 450.00px" src="img/6d0cec772642590c.png"></p>
<p>Open<code>BaseTest.java</code>in your IDE and paste in the following:</p>
<pre><code>// filename: tests/BaseTest.java
package tests;

import org.junit.Rule;
import org.junit.rules.ExternalResource;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.chrome.ChromeOptions;


public class BaseTest {

    protected WebDriver driver;

    @Rule
    public ExternalResource resource = new ExternalResource() {

        @Override
        protected void before() throws Exception {
            System.setProperty(&#34;webdriver.chrome.driver&#34;, &#34;/Users/lindsaywalker/Documents/chromedriver&#34;);
        ChromeOptions browserOptions = new ChromeOptions();
        driver = new ChromeDriver();
        }

        @Override
        protected void after() {
            driver.quit();
        }

    };

}
</code></pre>
<p>Notice the new JUnit annotation called <code>@Rule</code> which contains the JUnit<code>ExternalResources</code> rule. This rule has <code>before()</code> and<code>after()</code> methods that are used inside the <code>@Override</code> annotations.</p>
<p>These methods are implemented instead of the <code>@Before</code>and <code>@After</code> annotations, which you need to save for use (they can only be used once per test) within our test objects. Learn more about JUnit <a href="https://github.com/junit-team/junit4/wiki/Rules" target="_blank">Rules here</a>.</p>
<p>Now you need to modify your test objects to inherit what you created in the <code>BaseTest</code>class. Inside <code>TestLogin.java</code>, you&#39;ll get delete the following:</p>
<ul>
<li>The <code>@After</code> annotation and the use of it, since the <code>quit()</code> method was all that was in there, and is now used taken care of <code>BaseTest.java</code></li>
<li>Creation of the <code>Webdriver</code> instance</li>
<li>The instantiation of the<code>ChromeDriver</code> and the options</li>
</ul>
<p>The new<code>TestLogin.java</code> file should only contain the following:</p>
<pre><code>//filename: tests/TestLogin.java
package tests;

import org.junit.Before;
import org.junit.Test;
import org.openqa.selenium.WebDriver;
import pageobjects.Login;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

public class TestLogin extends BaseTest {
    private WebDriver driver;
    private Login login;

    @Before
    public void setUp() {
        login = new Login(driver);
    }

    @Test
    public void succeeded() {
        login.with(&#34;tomsmith&#34;, &#34;SuperSecretPassword!&#34;);
        assertTrue(&#34;success message not present&#34;,
                login.successMessagePresent());
    }
    @Test
    public void failed() {
        login.with(&#34;tomsmith&#34;, &#34;bad password&#34;);
        assertTrue(&#34;failure message wasn&#39;t present after providing bogus credentials&#34;,
                login.failureMessagePresent());
    }

    @Test
    public void failed2() {
        login.with(&#34;tomsmith&#34;, &#34;bad password&#34;);
        assertFalse(&#34;success message was present after providing bogus credentials&#34;,
                login.successMessagePresent());
    }
}

</code></pre>
<p>Next, you will make similar changes to <code>TestDynamicLoading.java</code>. First,  delete the following:</p>
<ul>
<li>The <code>@After</code> annotation and the use of it, since the <code>quit()</code> method is now taken care of in <code>BaseTest.java</code></li>
<li>Creation of the Webdriver instance</li>
<li>The instantiation of the<code>ChromeDriver</code> and the options</li>
</ul>
<p>The new <code>TestDynamicLoading.java</code>file should only contain the following:</p>
<pre><code>// filename: tests/TestDynamicLoading.java
package tests;

import org.junit.Before;
import org.junit.Test;
import pageobjects.DynamicLoading;

import static org.junit.Assert.assertTrue;

public class TestDynamicLoading extends BaseTest {

    private DynamicLoading dynamicLoading;

    @Before
    public void setUp() {
        dynamicLoading = new DynamicLoading(driver);
    }

    @Test
    public void hiddenElementLoads() {
        dynamicLoading.loadExample(&#34;1&#34;);
        assertTrue(&#34;finish text didn&#39;t display after loading&#34;,
                dynamicLoading.finishTextPresent());
    }

    @Test
    public void elementAppears() {
        dynamicLoading.loadExample(&#34;2&#34;);
        assertTrue(&#34;finish text didn&#39;t render after loading&#34;,
                dynamicLoading.finishTextPresent());
    }
}

</code></pre>
<h3 is-upgraded>NOTE</h3>
<aside class="warning"><p>Including the <code>quit()</code> function is extremely important for the speed &amp; passability of your tests. Without the quit method, the test will keep running even once all other methods have been executed until the default timeout has expired. This will not only slow down your ability to run many parallel tests at once, it will also send timeout error messages that could abort the test build.  This is now contained in <code>Base.java</code> and should never be excluded from any test.</p>
</aside>
<p>–</p>
<h3 is-upgraded>Final Code</h3>
<p class="image-container"><img alt="Test Login Updates" style="width: 750.00px" src="img/e74dc14063aef83e.png"></p>
<p class="image-container"><img alt="Test Dynamic Loading Updates" style="width: 750.00px" src="img/677e41059275f465.png"></p>
<h2 is-upgraded>Part 2: The Config File</h2>
<p>Typically, tests are run against different environments such as a local, test, staging, or production. We&#39;ll specify which environment you are using with a base URL in a separate config file (since the sub-domains such as /Login will stay the same, it will be easier to change testing environments in just the config file).</p>
<p>Create a new class in the tests directory called <code>Config.java</code>:</p>
<p class="image-container"><img alt="New Config File" style="width: 450.00px" src="img/319115ec977c23c7.png"></p>
<p>Inside of the class, you specify our<code>baseUrl</code> variable and have it fetch a runtime property of the same name. If there isn&#39;t one specified, the default will be used: <code>&#34;http://the-internet.herokuapp.com</code>&#34;.</p>
<p>Notice that the variable is <code>final</code> which makes it immutable, since you don&#39;t want configuration values to change after our tests start running.</p>
<pre><code>// filename: tests/Config.java

package tests;

public class Config {
    public static final String baseUrl = System.getProperty(&#34;baseUrl&#34;, &#34;http://the-internet.herokuapp.com&#34;);
}

</code></pre>
<p>Now you need to update the <code>Base</code> page object to use the URL you specified in <code>Config.java</code>. FIrst, update the <code>visit</code> method tin <code>Base.java</code>:</p>
<pre><code>// filename: pageobjects/Base.java
// ...
public class Base {

    private WebDriver driver;
    public Base(WebDriver driver) {
        this.driver = driver;
    }
    public void visit(String url) {
        if (url.contains(&#34;http&#34;))  {
            driver.get(url);
        } else {
            driver.get(baseUrl + url);
        }
    }
// ...
</code></pre>
<p>Next, you can import <code>Config</code> so you can use the <code>baseUrl</code> method:</p>
<pre><code>// filename: pageobjects/Base.java
// ...
import static tests.Config.*;
</code></pre>
<h3 is-upgraded>Final Code</h3>
<p>You can see the final code <a href="https://github.com/walkerlj0/Selenium_Course_Example_Code/tree/master/java/Mod4/4.03" target="_blank">here</a>. The Changes to <code>Base.java</code> should look like this:</p>
<p class="image-container"><img alt="New Config File" style="width: 650.00px" src="img/4c7893655e8dbef3.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="4.04 Running Tests in Different Browsers" duration="15">
        <h2 is-upgraded>Abstraction and Non-Duplication</h2>
<p>Thus far you have prepared our test suite well to be maintainable. When you have things like the setup and teardown used for all tests in one place, making changes to this becomes a lot easier. Not duplicating (re-writing the same) code and abstracting into files like the driver factory, spec helper, and base page mean that you won&#39;t have to re-write that code each time you write a new page or test object, or go make changes to all those files when you need to modify something.</p>
<h3 is-upgraded>Video</h3>
<p>Watch the video <a href="https://drive.google.com/file/d/1LkSIpQ7QBT0Uq5NyTgf0aUnALPy0e3jb/view?usp=sharing" target="_blank">4.04 Non-Duplication</a> an excerpt from <a href="https://www.youtube.com/watch?v=ZLS9sU2A9QA&t=24s" target="_blank">Sauce Labs&#39; Tech Talk</a> by Nikolay Advolodkin</p>
<iframe class="embedded-iframe" src="https://drive.google.com/file/d/1LkSIpQ7QBT0Uq5NyTgf0aUnALPy0e3jb/preview"></iframe>
<h2 is-upgraded>Part 1: Running Tests in Different Local Browsers</h2>
<h3 is-upgraded>Adding Drivers to Your Project</h3>
<p>WebDriver works with each of the major browsers through a browser driver which is (ideally but not always) maintained by the browser manufacturer. It is an executable file (consider it a thin layer) that acts as a bridge between Selenium and the browser.</p>
<p>Since you have been running tests locally, it works just fine to have the drivers on our machine, however, we&#39;ll be moving this to the cloud soon, so you should send the driver files with it. Under the driver directory in your project, right click and choose <strong>New &gt; Package</strong>, then name it drivers.</p>
<p class="image-container"><img alt="Drivers folder" style="width: 450.00px" src="img/b82bfb40a4396a5d.png"></p>
<p>Find the directory in your finder, and download both the most recent <a href="https://chromedriver.chromium.org/downloads" target="_blank">Chromedriver</a> and the <a href="https://github.com/mozilla/geckodriver/releases" target="_blank">Geckodoriver</a> for Firefox. First open each browser and check which version you are using for <a href="https://support.google.com/chrome/answer/95414?co=GENIE.Platform%3DDesktop&hl=en" target="_blank">Chrome</a>. For Firefox, download the latest version of the driver and the browser version will be added. _It is important to take note of the version you have of each. Write it down right now! _In this example, I have Chrome 85.0 on my machine, so I will download that driver version.</p>
<p class="image-container"><img alt="Add Drivers folder" style="width: 750.00px" src="img/f6bf07632008dfd2.png"></p>
<p>Download the latest version of each and save them in the drivers directory under where you have your test suite saved. Next, double click on the compressed files to unzip them. You should see <strong>chromedriver</strong> and <strong>geckodriver</strong> in your file directory.</p>
<p class="image-container"><img alt="Driver Directory" style="width: 750.00px" src="img/782b50ff7724721b.png"></p>
<h2 is-upgraded>Set Browser in Config File</h2>
<p>The first thing you will do is set the <code>browserName</code>in <code>Config.java</code>. Under the baseUrl variable, add a new one called <code>browserName</code>. This will give a default of Chrome, however when you run the test with Maven, you can still specify which one you will use.</p>
<pre><code>// filename: lib/config.java
// ...
public static final String browserName = System.getProperty(&#34;browserName&#34;, &#34;chrome&#34;);
}
</code></pre>
<p>Now you will create a new path to the files you installed as a part of your test suite. In <code>BaseTest.java</code> , update the file path in the <code>System.setProperty()</code>method and driver inside of the <code>before()</code> method, inside the first <code>@Override</code>annotation:</p>
<pre><code>// filename: lib/config.java
// ...
@Override
    protected void before() throws Exception {           
    System.setProperty(&#34;yourdriver.chrome.driver&#34;, &#34;src/test/java/drivers/chromedriver&#34;);
        ChromeOptions browserOptions = new ChromeOptions();
        driver = new ChromeDriver();
        }
    }

</code></pre>
<p>Try running your tests in IntelliJ just to make sure this new filepath works.</p>
<h3 is-upgraded>NOTE</h3>
<aside class="warning"><p>Often, web drivers are what is known as an ‘unsigned&#39; executable. This means that your operating system doesn&#39;t recognize it as a trusted piece of software. In this situation, you need to manually set your operating system. To do this on a Mac, go to <strong>System Preferences</strong> on your Mac <strong>&gt; Security &amp; Privacy</strong>, then under the <strong>General</strong> tab after unlocking the settings, choose the radio button to Allow apps downloaded from App Store and identified developers.</p>
</aside>
<aside class="warning"><p class="image-container"><img alt="Allow Unidentified FIles in Security and Privacy" style="width: 450.00px" src="img/d73ef7d5ed041783.png"></p>
</aside>
<aside class="warning"><p>On Windows, you can allow unidentified apps using <a href="https://support.microsoft.com/en-gb/help/4046851/windows-10-allow-blocked-app-windows-security" target="_blank">these instructions</a>. Another option you have is to find the driver you downloaded in the file directory and double-click to open the **chromedriver **or **geckodriver **manually.</p>
</aside>
<aside class="warning"><p>Another option is to simply look through your file directories on your computer and double click on the files to manually open them with terminal or command line. After you have allowed them to be opened once, your computer should allow the drivers to be run by your tests.</p>
</aside>
<p>–</p>
<h2 is-upgraded>Part 2: Run your Tests with Geckodriver</h2>
<p>First, at the bottom of the list of dependencies in the <code>pom.xml</code> file (right above the closing <code>&amp;lt;/dependencies&gt;</code> tag):</p>
<pre><code>// filename: pom.xml
// ...
        &lt;dependency&gt;
            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;
            &lt;artifactId&gt;selenium-firefox-driver&lt;/artifactId&gt;
            &lt;version&gt;3.141.59&lt;/version&gt;
        &lt;/dependency&gt;
// ...
</code></pre>
<p>You need to import the<code>browserName</code> variable from <code>Config.java.</code>At the bottom of your import list in <code>BaseTest.java,</code> add in:</p>
<pre><code>// filename: tests/BaseTest.java
// ...
import static tests.Config.*;
</code></pre>
<p>Update the <code>System.setProperty()</code>method in <code>BaseTest.java</code> and driver inside of the <code>before()</code> method, inside the first <code>@Override</code>annotation:</p>
<pre><code>// filename: tests/BaseTest.java
// ...
    @Override
        protected void before() throws Exception {
            if (browserName.equals(&#34;chrome&#34;)) {
                System.setProperty(&#34;webdriver.chrome.driver&#34;, &#34;src/test/java/drivers/chromedriver&#34;);
                ChromeOptions browserOptions = new ChromeOptions();
                driver = new ChromeDriver();
            } else if (browserName.equals(&#34;firefox&#34;)) {
                System.setProperty(&#34;webdriver.gecko.driver&#34;,
                        System.getProperty(&#34;webdriver.gecko.driver&#34;, &#34;src/test/java/drivers/geckodriver&#34;));
                driver = new FirefoxDriver();
            }
        }



</code></pre>
<p>In <code>BaseTest.java</code> you will also need to make sure you have imported the Firefox driver:</p>
<pre><code>// filename: tests/BaseTest.java
// ...
import org.openqa.selenium.firefox.FirefoxDriver;
// ...
</code></pre>
<p>Run your test with intelliJ. Because of the way the config file is set up currently, you should see your tests run and pass in Chrome. Next, make a change to <code>config.java</code>so that it will run firefox by changing the second parameter in the <code>browserName</code> variable from <code>&#39;chrome</code>&#39; to <code>&#39;firefox&#39;</code>.</p>
<pre><code>// filename: lib/config.java
// ...
public static final String browserName = System.getProperty(&#34;browserName&#34;, &#34;firefox&#34;);
}
</code></pre>
<h3 is-upgraded>Final Code</h3>
<p>You can see the final code <a href="https://github.com/walkerlj0/Selenium_Course_Example_Code/tree/master/java/Mod4/4.04" target="_blank">here</a>. The new code should look like this:</p>
<p class="image-container"><img alt="New Browser variable" style="width: 750.00px" src="img/6f576a90af9f70d7.png"></p>
<p class="image-container"><img alt="firefox driver dependency" style="width: 650.00px" src="img/5c8b44b2496eec30.png"></p>
<p class="image-container"><img alt="multiple browser options" style="width: 750.00px" src="img/225b56548e45fee7.png"></p>
<h2 is-upgraded>Quiz</h2>
<iframe class="embedded-iframe" src="https://docs.google.com/forms/d/e/1FAIpQLSfV9tlvi-6CPVRDmcXPl1Ddyc4V-ZX3P4lTWevGejDQhjbUGQ/viewform?embedded=true"></iframe>


      </google-codelab-step>
    
      <google-codelab-step label="4.05 Testing on Sauce Labs" duration="15">
        <p>In this lesson you are going to learn how to move the test suite that you have written from your local machine onto the <a href="https://accounts.saucelabs.com/am/XUI/#login/?utm_source=referral&utm_medium=LMS&utm_campaign=link" target="_blank">Sauce Labs</a> cloud provider. They maintain a set of real and virtual devices, as well as a Selenium grid that you can use to run your test in almost any environment. There are many reasons this is advantageous:</p>
<ul>
<li>You can use virtual machines (without having to set it up on your own machine)  <ul>
<li>To test older versions of operating systems</li>
<li>Test browsers that only run on older operating systems.</li>
</ul>
</li>
<li>You don&#39;t have to provision all the different kinds of virtual machines you will need yourself</li>
<li>You don&#39;t have to set up and maintain the Selenium Grid that will coordinate the test across all of these different machines</li>
</ul>
<p>To do this you are going to need something called the <em>Selenium Grid</em> and the <em>RemoteWebdriver.</em>  The Selenium Grid lets you distribute test execution across several machines and you connect to it with Selenium _RemoteWebDrive_r.</p>
<p>You tell the Grid which browser and OS you want your test to run on through the use of Selenium&#39;s class object <a href="https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/MutableCapabilities.html" target="_blank">MutableCapabilities</a>, and its various subclasses for specific browser options (ChromeOptions, FirefoxOptions, etc.) Sauce Labs has <a href="https://github.com/saucelabs/sauce_bindings" target="_blank">specific language bindings</a> that act as wrappers for supported programming languages.</p>
<h2 is-upgraded>Part 1: Update Desired Capabilities</h2>
<p>In the<code>Config.java</code> file, you are going to communicate the settings for our test environment with the W3C _<a href="https://wiki.saucelabs.com/display/DOCS/Desired+Capabilities+Required+for+Selenium+and+Appium+Tests/?utm_source=referral&utm_medium=LMS&utm_campaign=link" target="_blank">Capabilities</a>_, required for every Selenium test.</p>
<p>In addition, you need to define some variables for your tests to be able to communicate with Sauce Labs:</p>
<pre><code>// filename: tests/Config.java
package tests;

public class Config {
    public static final String baseUrl = System.getProperty(&#34;baseUrl&#34;, &#34;http://the-internet.herokuapp.com&#34;);
    public static final String host = System.getProperty(&#34;host&#34;, &#34;saucelabs&#34;);
    public static final String browserName = System.getProperty(&#34;browserName&#34;, &#34;chrome&#34;);
    public static final String browserVersion = System.getProperty(&#34;browserVersion&#34;, &#34;75.0&#34;);
    public static final String platformName = System.getProperty(&#34;platformName&#34;, &#34;Windows 10&#34;);
    public static final String sauceUser = System.getenv(&#34;SAUCE_USERNAME&#34;);
    public static final String sauceKey = System.getenv(&#34;SAUCE_ACCESS_KEY&#34;);
}




</code></pre>
<p>Notice the new variables you have added:</p>
<ul>
<li><code>host</code>enables us to specify whether our tests run locally or on Sauce Labs. Right now, the host is either<code>&#34;saucelabs</code>&#34; or <code>&#34;localhost&#34;</code></li>
<li>The <a href="https://wiki.saucelabs.com/display/DOCS/Test+Configuration+Options" target="_blank">Sauce Labs Test Configuration Options</a> contains information for each specific test. You assume you may pass in unique usernames and access keys  <ul>
<li><code>browserName</code> specifies the browser for a test.</li>
<li><code>browserVersion</code> specifies which version of the browser for a test</li>
<li><code>platformName</code> specifies the operating system for a test.</li>
<li><code>username</code> is the username you have created for Sauce Labs</li>
<li><code>accessKey</code> is generated (and can be regenerated) in your user settings in Sauce Labs</li>
</ul>
</li>
</ul>
<h2 is-upgraded>Final Code</h2>
<p>Notice how many of the capabilities are grey in this example, since they aren&#39;t yet use in the code: <img alt="Capabilities for your test" style="width: 750.00px" src="img/7669f7320b05c492.png"></p>
<h2 is-upgraded>Setting up your Sauce Labs Account</h2>
<p>You&#39;ll need an account to use Sauce Labs. Their <a href="https://accounts.saucelabs.com/am/XUI/#login/?utm_source=referral&utm_medium=LMS&utm_campaign=link" target="_blank">free trial</a> offers enough to get you started. And if you&#39;re signing up because you want to test an open source project, then be sure to check out their <a href="https://saucelabs.com/open-source" target="_blank">Open Sauce account</a>.</p>
<p>Visit <a href="https://accounts.saucelabs.com/am/XUI/#login/?utm_source=referral&utm_medium=LMS&utm_campaign=link" target="_blank">http://app.saucelabs.com/</a>. You can create a free trial account if you haven&#39;t been assigned one.</p>
<p class="image-container"><img alt="Sauce Labs Account" style="width: 450.00px" src="img/2671b7c651736e0d.png"></p>
<p>Go to <strong>Account&gt; User Settings</strong> to find your username and access key.</p>
<p class="image-container"><img alt="Sauce Labs User Name Access Key" style="width: 450.00px" src="img/15746d8eaf43260d.png"></p>
<p>You will need to set up your username and access key on your machine&#39;s environment variables either in your bash profile (Mac/Linux) or in the system properties (Windows).</p>
<p>To learn more about setting up environment variables, you can see the article <a href="https://wiki.saucelabs.com/display/DOCS/Best+Practice%3A+Use+Environment+Variables+for+Authentication+Credentials#BestPractice:UseEnvironmentVariablesforAuthenticationCredentials-SettingUpEnvironmentVariablesonMacOSX/LinuxSystems" target="_blank">here</a>.</p>
<h3 is-upgraded>Video</h3>
<p>Watch This Video to See how to set up your Sauce Credentials as environment variables on MacOS <a href="https://drive.google.com/file/d/1qezKtvBpn94bBTJgbAd2MSx4ByNx7oaz/view?usp=sharing" target="_blank">4.05 Sauce Credentials</a></p>
<iframe class="embedded-iframe" src="https://drive.google.com/file/d/1qezKtvBpn94bBTJgbAd2MSx4ByNx7oaz/preview"></iframe>
<h2 is-upgraded>Part 2: Use the Remote Web Driver</h2>
<p>Now you need to update <code>BaseTest.java</code>to work with these new values and connect to Sauce Labs. Note that these are called _<a href="https://wiki.saucelabs.com/display/DOCS/Test+Configuration+Options" target="_blank">Capabilities</a>, _and the format they are in here is compatible with the Selenium 4.0 web driver and backwards compatible. They set the options for setting up the environment for your tests.</p>
<pre><code>// filename: tests/BaseTest.java
// ...
  @Override
        protected void before() throws Exception {
            if (host.equals(&#34;saucelabs&#34;)) {
                MutableCapabilities sauceOptions = new MutableCapabilities();
                sauceOptions.setCapability(&#34;username&#34;, sauceUser);
                sauceOptions.setCapability(&#34;accessKey&#34;, sauceKey);
                MutableCapabilities capabilities = new MutableCapabilities();
                capabilities.setCapability(&#34;browserName&#34;, browserName);
                capabilities.setCapability(&#34;browserVersion&#34;, browserVersion);
                capabilities.setCapability(&#34;platformName&#34;, platformName);
                capabilities.setCapability(&#34;sauce:options&#34;, sauceOptions);
                String sauceUrl = String.format(&#34;https://ondemand.saucelabs.com/wd/hub&#34;);
                driver = new RemoteWebDriver(new URL(sauceUrl), capabilities);
            } else if (host.equals(&#34;localhost&#34;)) {
                if (browserName.equals(&#34;firefox&#34;)) {
                    System.setProperty(&#34;webdriver.gecko.driver&#34;,
                            System.getProperty(&#34;webdriver.gecko.driver&#34;, &#34;src/test/java/drivers/geckodriver&#34;));
                    driver = new FirefoxDriver();
                } else if (browserName.equals(&#34;chrome&#34;)) {
                    System.setProperty(&#34;webdriver.chrome.driver&#34;, &#34;src/test/java/drivers/chromedriver&#34;);
                    ChromeOptions browserOptions = new ChromeOptions();
                    driver = new ChromeDriver();
                }
            }
        }


</code></pre>
<p>This has two if/ else statements:</p>
<ul>
<li>The first one checks to see if you have set your test to run on the <code>&#34;localhost&#34;</code> or<code>&#34;saucelabs&#34;.</code></li>
<li>The second, nested in the localhost condition, sets your test up to use the Geckodriver or Chromedriver saved in your project folder, depending on which browser you have set your test to use.</li>
</ul>
<p>Now you can import the <code>MutableCapabilities</code>and<code>RemoteWebDriver</code> Selenium classes, as well as the<code>URL</code> java class. Add these imports in <code>BaseTest.java</code>:</p>
<pre><code>// filename: tests/BaseTest.java
// ...
import org.openqa.selenium.MutableCapabilities;
import org.openqa.selenium.remote.RemoteWebDriver;
import java.net.URL;
// ...
</code></pre>
<h2 is-upgraded>Run Your Tests</h2>
<p>Now you can use terminal commands to run your tests on Sauce Labs while specifying the <code>browserName</code>,<code>browserVersion</code>, and <code>platformName</code>. As an example, if you run this command the test will be run in Sauce Labs in on MacOS 10.10 in the Chrome 75 browser:</p>
<pre><code>mvn clean test -Dhost=saucelabs -DbrowserName=chrome -DbrowserVersion=75 -Dplatform=&#34;OS X 10.10&#34;
</code></pre>
<p>You should also visit <a href="http://app.saucelabs.com/" target="_blank">http://app.saucelabs.com/</a>. Go to the left hand menu and choose <strong>Automated → Test Results</strong>. There you will see your tests with icons indicating they were run on the operating system &amp; browser that you chose:</p>
<p class="image-container"><img alt="Jobs Run on Sauce" style="width: 550.00px" src="img/e5d7183e09871866.png"></p>
<h3 is-upgraded>NOTE</h3>
<aside class="warning"><p>What did you do? At this point to create an instance of a test, you are dependent on several different objects in your test suite. First, <code>Base</code> sets up methods used by your page objects and instantiates a Selenium Webdriver instance. The page objects like <code>Login</code> and <code>Dynamic Loading</code> use the Base class (and the methods) to interact with the pages.</p>
</aside>
<aside class="warning"><p>Once the interactions with the webpage are taken care of, the tests come into play.<code>BaseTest</code> imports the settings from <code>Config</code>, then the tests use the <code>Base</code> class and define the specific tests run on the page.</p>
</aside>
<aside class="warning"><p class="image-container"><img alt="Test Suite Structure" style="width: 750.00px" src="img/2f6063c6fc6447a2.png"></p>
</aside>
<p>–</p>
<h3 is-upgraded>Final Code</h3>
<p>The complete code can be found <a href="https://github.com/walkerlj0/Selenium_Course_Example_Code/tree/master/java/Mod4/4.05" target="_blank">here</a>. Your final code will look like this:</p>
<p class="image-container"><img alt="Image Name" style="width: 750.00px" src="img/1d46082f7f15abe9.png"></p>
<p class="image-container"><img alt="Image Name" style="width: 750.00px" src="img/3445f5cc9b871e6c.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="4.06  Setup for Sauce Labs Reporting" duration="12">
        <p>In this lesson you will add in some elements for better reporting to understand the status of test run on the<a href="https://accounts.saucelabs.com/am/XUI/#login/?utm_source=referral&utm_medium=LMS&utm_campaign=link" target="_blank"> Sauce Labs automated web testing platform</a>.</p>
<p>Now that your tests are up and running on the Sauce Labs platform, you&#39;ll notice it&#39;s hard to tell one apart from the other. The tests you should have run will show up as <strong>Unnamed job</strong> with a hash identifier- not easy to use for testing and debugging.</p>
<p class="image-container"><img alt="Unnamed Job" style="width: 550.00px" src="img/880ba3c69a244afb.png"></p>
<p>To fix this issue, you can pull in the name and the status from the test and send it to the <a href="https://accounts.saucelabs.com/am/XUI/#login/?utm_source=referral&utm_medium=LMS&utm_campaign=link" target="_blank">Sauce Labs dashboard </a>so you can use our tests to effectively debug and improve our application.</p>
<p>In addition, right now regardless of the outcome of a test, the job in Sauce Labs will register as <strong>Finished.</strong> Ideally you want to know if the job was a <strong>Pass</strong> or a <strong>Fail</strong>. That way we can tell at a glance if a test failed or not. With a couple of tweaks we can make this happen easily enough.</p>
<h2 is-upgraded>Part 1 Add a Test Name</h2>
<p>It&#39;s great that our tests are running on Sauce Labs. But we&#39;re not done yet because the test name in each Sauce job is getting set to an unnamed job. This makes it extremely challenging to know which tests were run in each job. This code will allow you to pass the test name to Sauce Labs.</p>
<p>In<code>BaseTest</code> you will use another <a href="https://github.com/junit-team/junit4/wiki/Rules#testwatchmantestwatcher-rules" target="_blank">JUnit rule</a> called <code>TestWatcher().</code> First you will need to create a string variable in the<code>BaseTest</code>class underneath where you instantiate the driver.</p>
<pre><code>// filename: lib/DriverFactory.js
// ...
private String testName;
// ...
</code></pre>
<p>Next, use the  <code>TestWatcher()</code>after the second<code>@Override</code>annotation, right before the final closing curly braces. It has a method called <code>starting</code> that gives us access to the description of each test as its starting. So yougrab the display name for the test and store it in the <code>testName</code>string variable.</p>
<pre><code>// filename: lib/DriverFactory.js
// ...
    @Rule
    public TestRule watcher = new TestWatcher() {
        @Override
        protected void starting(Description description) {
            testName = description.getDisplayName();
        }
    };
}
</code></pre>
<p>At the top of <code>BaseTest</code>, make sure you import <code>TestRule</code> and <code>TestWatcher</code> and the <code>Description</code> in the list of imports at the top:</p>
<pre><code>// filename: tests/BaseTest.java
// ...
import org.junit.rules.TestRule;
import org.junit.rules.TestWatcher;
import org.junit.runner.Description;

// ...

</code></pre>
<p>Now you can add it to <a href="https://opensource.saucelabs.com/sauce_bindings/docs/basic-options" target="_blank">Sauce Options</a> in between<code>platformName</code>after the <code>accessKey</code> and before the list of <code>Mutable Capabilities</code>:</p>
<pre><code>// filename: tests/BaseTest.java
// ...
sauceOptions.setCapability(&#34;name&#34;, testName);
// ...

</code></pre>
<p>Run <code>mvn clean test -Dhost=saucelabs</code> to see if it works. Now when you run our tests in Sauce Labs, the <a href="https://accounts.saucelabs.com/am/XUI/#login/?utm_source=referral&utm_medium=LMS&utm_campaign=link" target="_blank">account dashboard</a> will show the tests running with the name of the test outside of the parentheses, and the class inside of the parentheses:</p>
<h2 is-upgraded>Add a Test Status</h2>
<p>After adding a test name, youwill add in an id and status for each unique test that you create. First, you will need to update our tests. If you noticed before, the only status was <strong>Complete</strong> or had an <strong>Error</strong>. You will now add in whether a test has passed or failed.</p>
<p class="image-container"><img alt="Error or Complete" style="width: 750.00px" src="img/a4600ed4a22484ef.png"></p>
<p>A _failure _is different from an <em>error</em>. An error means that you test code is erroneous, and you, as the test writer, need to make a change. You should see this error in your terminal output, and if the code is correct to communicate with Sauce Labs, it should be on your dashboard as well. A failure means a test successfully ran, but the conditions it was checking for were not present – in other words, the code for the app isn&#39;t as expected or needs fixing.</p>
<p>You&#39;ll first need install the <code>saucerest</code> library by adding it to our <code>pom.xml</code>file within the <code>&amp;lt;dependencies&gt;</code> tags.</p>
<pre><code>// filename: pom.xml
// ...
        &lt;dependency&gt;
            &lt;groupId&gt;com.saucelabs&lt;/groupId&gt;
            &lt;artifactId&gt;saucerest&lt;/artifactId&gt;
            &lt;version&gt;1.0.40&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;

// ...

</code></pre>
<h2 is-upgraded>NOTE</h2>
<aside class="warning"><p>If you add a dependency and the text appears in red (Maven isn&#39;t recognizing it) you can right click on the pom.xml file in the project directory in IntelliJ then choose <strong>Maven &gt; Reload project</strong>:</p>
</aside>
<aside class="warning"><p class="image-container"><img alt="Reload project with Maven" style="width: 750.00px" src="img/fdbebe5798eb96be.png"></p>
</aside>
<p>–</p>
<p>In the variable list of the<code>BaseTest</code> class (below <code>private string testName;</code>) add in the following:</p>
<pre><code>// filename: tests/BaseTest.java
// ...
    private String sessionId;
    private SauceREST sauceClient;
// ...
</code></pre>
<p>Under the saucelabs<code>driver</code> instantiation in the<code>before()</code> rule instantiate a<code>sessionId</code> and <code>sauceClient</code> for when you are running tests on Sauce Labs:</p>
<pre><code>// filename: tests/BaseTest.java
// ...
        sessionId = ((RemoteWebDriver) driver).getSessionId().toString();
        sauceClient = new SauceREST(sauceUser, sauceKey, DataCenter.US);

// ...
</code></pre>
<p>The <code>sessionId</code> is retrieved from the <code>RemoteWebDriver</code>. The <code>sauceClient</code> creates an instance using the Sauce Labs REST API, passing in the username, access key, and data center location. You can change the data center on the Sauce Labs dashboard. Once that is changed, if you would like, go into your code and <a href="https://wiki.saucelabs.com/display/DOCS/Data+Center+Endpoints" target="_blank">change</a> the <code>DataCenter</code> option in your code to reflect this.</p>
<p class="image-container"><img alt="Data Center" style="width: 750.00px" src="img/ef3301faf6c00165.png"></p>
<p>Now you can<code>import</code> the <code>sauceRest</code> package in the<code>imports</code> list of <code>BaseTest.java</code>:</p>
<pre><code>// filename: tests/BaseTest.java
// ...
import com.saucelabs.saucerest.SauceREST;
// ...
</code></pre>
<p>Now, go down to the<code>TestWatcher</code> rule. Under the first<code>@Override</code> annotation, add in two more:</p>
<pre><code>// filename: tests/BaseTest.java
// ...
@Override
        protected void failed(Throwable throwable, Description description) {
            if (host.equals(&#34;saucelabs&#34;)) {
                sauceClient.jobFailed(sessionId);
                System.out.println(String.format(&#34;https://saucelabs.com/tests/%s&#34;, sessionId));
            }
        }

        @Override
        protected void succeeded(Description description) {
            if (host.equals(&#34;saucelabs&#34;)) {
                sauceClient.jobPassed(sessionId);
            }
        }
// ...
</code></pre>
<p>Once a Sauce job is established we&#39;re able to get the session ID from <code>RemoteWebDriver</code> and store it&#39;s string value in<code>sessionId</code>. youthen create an instance of <code>SauceREST</code> (which connects to the Sauce API) and store the session in <code>sauceClient</code>.</p>
<p>With a conditional check in each you make sure the sauceClient commands only trigger when a Sauce session has been established.</p>
<p>When a test is successful the <code>succeeded()</code> method will fire, marking the Sauce job for the test as <code>passed</code>. When a test fails the failed method will trigger, and the job will be marked as <code>failed</code>. When there&#39;s a failure, we&#39;ll want to know the URL to view the job on <a href="https://accounts.saucelabs.com/am/XUI/#login/?utm_source=referral&utm_medium=LMS&utm_campaign=link" target="_blank">SauceLabs </a>so you concatenate the URL and output it to the console using the <code>System.out.println</code> command.</p>
<p>Now when you run <code>mvn clean test -Dhost=saucelabs</code>in terminal, then check your <a href="https://accounts.saucelabs.com/am/XUI/#login/?utm_source=referral&utm_medium=LMS&utm_campaign=link" target="_blank">Sauce Labs dashboard</a>. On the right you should be able to see a status of passed with each test.</p>
<p class="image-container"><img alt="Passed Tests" style="width: 550.00px" src="img/8200652afc611406.png"></p>
<p>You can see an example of the completed code<a href="https://github.com/walkerlj0/Selenium_Course_Example_Code/tree/master/java/Mod4/4.06" target="_blank"> here.</a></p>
<h3 is-upgraded>Final Code</h3>
<p class="image-container"><img alt="Test Rule and Watcher" style="width: 550.00px" src="img/af337b297ec72128.png"></p>
<p class="image-container"><img alt="Session ID and SauceREST API" style="width: 750.00px" src="img/9ffe562deb5b2093.png"></p>
<p class="image-container"><img alt="Test Watcher" style="width: 750.00px" src="img/d0f43c180055bcf9.png"></p>
<p class="image-container"><img alt="Sauce Rest in pom.xml" style="width: 650.00px" src="img/960e968227ba9928.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="4.07 Quiz" duration="5">
        <iframe class="embedded-iframe" src="https://docs.google.com/forms/d/e/1FAIpQLSdiPBDahX6pf0akZmn0ogA4JLInFa4EAb5HXy-VAa3lsIyEyQ/viewform?embedded=true"></iframe>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
